/* Filename: lexer.lxx */

%{
	#include "lexer.hxx"
	#include "parser.hxx"

	#define yylex run_lexer
	#define yyerror lexer_error
	#define yywarning lexer_warning

	using namespace std;

	/* Defined Constants */
	static const int max_string_width = 8192;
	static const int max_error_width = 1024;

	/* Defined Types */
	// A LexerFile keeps track of file specific state information for the lexer.
	struct LexerFile {
		string filename;
		unsigned int line_number;
		unsigned int col_number;

		// current_line holds the current line for output in an error report
		char current_line[max_error_width + 1];
	};

	/* Static Variables */
	static LexerFile* current_file = (LexerFile*)NULL;
	static int error_count = 0;
	static int warning_count = 0;


	/* Function Declarations */
	// accept is called below as each piece is pulled off and
	// accepted by the lexer; it increments the current column number.
	inline void accept();

	// read_char reads and returns a single character, incrementing the supplied line and column
	// numbers as appropriate.  A convenience function for the scanning functions below.
	static int read_char(int &line, int &col);

	// todo: doc
	static char* scan_block_comment();
	static char* scan_string_literal();
	static char scan_character_literal();

%}

BOOLEAN_LITERAL (true|false)
OCTAL_LITERAL   (0)
DECIMAL_LITERAL ([1-9]+[0-9]*)
FLOAT_LITERAL   ((([0-9]+[.])|([0-9]*[.][0-9]+))([eE][+-]?[0-9]+)?)

/*
// These regexs are correct to the specification, but we're using simplified
//     versions until someone feels the need to implement them.

HEXNUM_LITERAL  (0x[0-9a-fA-F]*([uU](l|L|ll|LL)?|(l|L|ll|LL)[uU]?)?)
BINARY_LITERAL  (0[bB][01]+([uU](l|L|ll|LL)?|(l|L|ll|LL)[uU]?)?)
DECIMAL_LITERAL ([1-9]+[0-9]*([uU](l|L|ll|LL)?|(l|L|ll|LL)[uU]?)?)
FLOATING_POINT  ((([0-9]+[.])|([0-9]*[.][0-9]+))([eE][+-]?[0-9]+)?[lLfF]?)
OCTAL_LITERAL   (0[0-7]*([uU](l|L|ll|LL)?|(l|L|ll|LL)[uU]?)?)
*/

%%

%{
	// quick trick till we initialize the lexer, just make a LexerFile to work with
	//     atm, this causes a minor memleak that we're ignoring
	if(current_file == (LexerFile*)NULL)
	{
		current_file = new LexerFile;
		current_file->filename = "<<input file>>";
		current_file->line_number = 0;
		current_file->col_number = 0;
	}
%}


\n.* {
	// New line.  Save a copy of the line so we can print it out for the
	// benefit of the user in case we get an error.

	strncpy(current_file->current_line, yytext + 1, max_error_width);
	current_file->current_line[max_error_width] = '\0';
	current_file->line_number++;
	current_file->col_number = 0;

	// Return the whole line to the lexer, except the newline character,
	// which we eat.
	yyless(1);
}

"#".* {
	// Preprocessor operation
	yyerror("Preprocessor directives not handled yet");
}

"enum" {
	accept();
	return KW_ENUM;
}

"class" {
	accept();
	return KW_CLASS;
}

"struct" {
	accept();
	return KW_STRUCT;
}

"typedef" {
	accept();
	return KW_TYPEDEF;
}

"/*" {
	// Comment block
	accept();
	yylval.string = scan_block_comment();
	return COMMENT;
}

"//".* {
	// C++-style comment
	accept();

	// (-2) to exclude the "//", and (+1) for null-byte
	size_t malloc_size = (yyleng - 2) + 1;
	if(malloc_size > max_string_width) {
		yywarning("Comment was truncated because it was too long.");
		malloc_size = max_string_width;
	}

	char* comment = (char*)malloc(malloc_size);
	strncpy(comment, &yytext[2], malloc_size);
	comment[malloc_size] = '\0';
	yylval.string = comment;

	return COMMENT;
}

["] {
	// String literal (")
	accept();
	yylval.string = scan_string_literal();
	return STRING;
}

['] {
	// Character literal (')
	accept();
	yylval.character = scan_character_literal();
	return CHAR;
}

{BOOLEAN_LITERAL} {
	// Boolean literal
	accept();
	if(strcmp(yytext, "true") == 0) {
		yylval.boolean = true;
	} else {
		yylval.boolean = false;
	}
	return BOOLEAN;
}

{OCTAL_LITERAL} {
	// Octal literal (currently we just accept 0)
	accept();
	yylval.integer = 0;
	return INTEGER;
}

{DECIMAL_LITERAL} {
	// Decimal literal
	accept();
	yylval.integer = atoi(yytext);
	return INTEGER;
}

{FLOAT_LITERAL} {
	// Floating-point literals
	accept();
	yylval.floating = atof(yytext);
	return FLOAT;
}

. {
	// Send any other printable character as itself.
	accept();
	return yytext[0];
}

%%

// read_char reads and returns a single character, incrementing the supplied line and column
// numbers as appropriate.  A convenience function for the scanning functions below.
static int read_char(int &line, int &col) {
	int c = yyinput();
	if (c == '\n') {
		line++;
		col = 0;
	} else {
		col++;
	}
	return c;
}

// accept is called above as each piece is pulled off and
// accepted by the lexer; it increments the current column number.
inline void accept() {
	current_file->col_number += yyleng;
}

int lexer_error_count() { return error_count; }
int lexer_warning_count() { return warning_count; }