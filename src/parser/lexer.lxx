/* Filename: lexer.lxx */

%{
	#include "lexer.h"
	#include "parser.h"
	#include "parser.dxx"

	#include "cpp.h"

	#include <cctype>        // isxdigit
	#include <iostream>      // std::cerr, std::ostream
	#include <deque>         // std::deque

	#define yyerror lexer_error
	#define yywarning lexer_warning

	#define YY_DECL int run_lexer(void)

	using namespace std;

	/* Struct Definitions */
	// An Input holds extra per-file information while lexing and parsing
	struct Input : File
	{
		Input(const string& name = "<???>");

		string current_line; // holds the current line for error reporting
		list<string> comments;
		int line_number; // current line of the input
		int col_number; // current col of the input
		int times_included; // number of times the file has been included
	};

	/* Lexer State */
	static int error_count;
	static int warning_count;
	static int is_conditional_source;
	static deque<Input*> inputs;
	static Module* current_module = NULL;
	#define defines (current_module->defines)
	#define files (current_module->files)

	#define echo() \
		cout << "Token(" << inputs.front()->name << "): " << yytext << "\n"

	/* Function Declarations */
	// emit outputs the specified token from the lexer with location information
	#define emit(token)                                        echo();\
		yylloc.last_line = inputs.front()->line_number;        \
		yylloc.last_column = inputs.front()->col_number;       \
		if(!inputs.front()->comments.back().empty()) {         \
			yylloc.comment = &inputs.front()->comments.back(); \
			inputs.front()->comments.push_back("");            \
		}                                                      \
		return token
		
	// accept is called below when receiving a regex from the lexer;
	//     it increments the current column number, and sets some location information
	static void accept();

	// accept_include is an alternate accepts that handles the #include directive;
	//     returns if there was an error with the include.
	static bool accept_include(char end_mark);

	// peek_char returns the character that will be returned in
	//     the next call to read_char.
	inline int peek_char();

	// read_char reads and returns a single character,
	//     incrementing the line and column numbers as appropriate.
	inline int read_char();
	static int read_char(int & line, int & col);

	// todo: doc
	inline char read_char_const(bool auto_escape = false);
	static char read_char_const(int & line, int & col, bool auto_escape = false);

	// todo: doc
	static bool scan_if();
	static bool scan_if_condition(); // used by scan_if
	static bool scan_if_logic(bool); // used by scan_if
	static void scan_if_end();       // used by scan_if
	static void scan_define(const string& identifier);
	static string scan_block_comment();
	static string scan_string_literal(char quote_mark = '"');
%}

/* Flex Options */
%option stack
%option warn
%option noyywrap

/* Lexer States */
%x pragma
%x include
%x ifdef
%x ifndef
%x define
%x undef
%x endif

%x ifcond
%x ifident
%x iflogic

/* Regex Definitions */
IDENTIFIER      [A-Za-z_][A-Za-z_0-9]*
BOOLEAN_LITERAL true|false
OCTAL_LITERAL   0
DECIMAL_LITERAL [1-9]+[0-9]*
FLOAT_LITERAL   (([0-9]+[.])|([0-9]*[.][0-9]+))([eE][+-]?[0-9]+)?

/*"/*
// These regexs are correct to the specification, but we're using simplified
//     versions until someone feels the need to implement them.

HEXNUM_LITERAL  (0x[0-9a-fA-F]*([uU](l|L|ll|LL)?|(l|L|ll|LL)[uU]?)?)
BINARY_LITERAL  (0[bB][01]+([uU](l|L|ll|LL)?|(l|L|ll|LL)[uU]?)?)
DECIMAL_LITERAL ([1-9]+[0-9]*([uU](l|L|ll|LL)?|(l|L|ll|LL)[uU]?)?)
FLOATING_POINT  ((([0-9]+[.])|([0-9]*[.][0-9]+))([eE][+-]?[0-9]+)?[lLfF]?)
OCTAL_LITERAL   (0[0-7]*([uU](l|L|ll|LL)?|(l|L|ll|LL)[uU]?)?)
*/

%%

\n.* {
	// New line.  Save a copy of the line so we can print it out for the
	// benefit of the user in case we get an error.

	inputs.front()->current_line = yytext+1;
	inputs.front()->line_number++;
	inputs.front()->col_number = 0;

	// Return the whole line to the lexer, except the newline character, which we eat.
	yyless(1);
}

\n[ \t]*\n.* {
	// An empty line will clear our current comment
	// This option overrides (\n.*) because it produces a longer output
	if(!inputs.front()->comments.back().empty()) {
		inputs.front()->comments.push_back("");
	}

	inputs.front()->current_line = yytext+2;
	inputs.front()->line_number += 2;
	inputs.front()->col_number = 0;

	// Return the whole line to the lexer, except the newline characters, which we eat.
	yyless(2);
}

[ \t\v\r\f] {
	// Eat whitespace.
	accept();
}

"#"[ \t]*"pragma"[ \t]+ {
	// Preprocessor #pragma directive
	accept();
	BEGIN(pragma);
}

"#"[ \t]*"include"[ \t]+ {
	// Preprocessor #include directive
	accept();
	BEGIN(include);
}

"#"[ \t]*"if"[ \t]+ {
	accept();

	is_conditional_source++;
	if(!scan_if()) {
		BEGIN(endif);
	}

	cout << "#if\n";
}

"#"[ \t]*"ifdef"[ \t]+ {
	// Preprocessor #ifdef directive
	accept();
	BEGIN(ifdef);
}

"#"[ \t]*"ifndef"[ \t]+ {
	// Preprocessor #ifndef directive
	accept();
	BEGIN(ifndef);
}

"#"[ \t]*"define"[ \t]+ {
	// Preprocessor #define directive
	accept();
	BEGIN(define);
}

"#"[ \t]*"undef"[ \t]+ {
	// Preprocessor #undef directive
	accept();
	BEGIN(undef);
}

"#"[ \t]*"else".* {
	accept();
	if(!is_conditional_source) {
		yyerror("Found #else without previous #if.");
	} else {
		BEGIN(endif);
	}
}

"#"[ \t]*"endif".* {
	// Preprocessor #endif directive
	accept();
	if(!is_conditional_source) {
		yyerror("Found #endif without previous #if.");
	} else {
		cout << "#endif\n";
		is_conditional_source--;
	}
}

"#" {
	// Fail on all other preprocessor ops
	accept();
	yyerror("Treesap hasn't implemented this preprocessor directive yet.");

	// Consume the rest of the line, except the newline (\n) character
	int c = peek_char();
	while(c!= '\n' && c != EOF) {
		read_char();
		c = peek_char();
	}
}

<pragma,include,ifndef,ifdef,define,undef>[ \t]* {
	accept(); // eat whitespace everywhere
}

<pragma>"once".* {
	accept();
	if(inputs.front()->times_included > 1) {
		inputs.pop_front();
	}
	BEGIN(INITIAL);
}

<pragma>[^ \t\n]+.* {
	accept();

	string msg;
	msg += "Treesap doesn't currently support \"#pragma ";
	msg += yytext;
	msg += "\".";
	yyerror(msg);

	BEGIN(INITIAL);
}

<include>["] {
	// Reads a quoted (") include (& following junk)
	accept();
	if(!accept_include('"')) { yyterminate(); }
	else { BEGIN(INITIAL); }
}
<include>[<] {
	// Reads a braced (<>) include (& following junk)
	accept();
	if(!accept_include('>')) { yyterminate(); }
	else { BEGIN(INITIAL); }
}

<include>[^"< \t\n]+.* {
	// Accepts any character except spaces, <, or "
	accept();

	string msg;
	msg += "Found unexpected \"";
	msg += yytext;
	msg += "\" in #include directive.";
	yyerror(msg);

	BEGIN(INITIAL);
}

<ifdef>{IDENTIFIER} {
	accept();

	is_conditional_source++;
	if(defines.find(yytext) == defines.end()) {
		BEGIN(endif);
	} else {
		cout << "#ifdef " << yytext << "\n";
		BEGIN(INITIAL);
	}

	// Consume the rest of the line, except the newline (\n) character
	int c = peek_char();
	while(c!= '\n' && c != EOF) {
		read_char();
		c = peek_char();
	}
}

<ifdef>. {
	accept();

	string msg;
	msg += "Found unexpected \"";
	msg += yytext;
	msg += "\" after #ifdef directive.";
	yyerror(msg);

	BEGIN(endif);
}

<ifndef>{IDENTIFIER} {
	accept();

	is_conditional_source++;
	if(defines.find(yytext) == defines.end()) {
		cout << "#ifndef " << yytext << "\n";
		BEGIN(INITIAL);
	} else {
		BEGIN(endif);
	}

	// Consume the rest of the line, except the newline (\n) character
	int c = peek_char();
	while(c!= '\n' && c != EOF) {
		read_char();
		c = peek_char();
	}
}

<ifndef>. {
	accept();

	string msg;
	msg += "Found unexpected \"";
	msg += yytext;
	msg += "\" in #ifndef directive.";
	yyerror(msg);

	BEGIN(endif);
}

<define>{IDENTIFIER} {
	accept();
	scan_define(yytext);
	BEGIN(INITIAL);
}

<undef>{IDENTIFIER} {
	accept();
	defines.erase(yytext);

	// Consume the rest of the line, except the newline (\n) character
	int c = peek_char();
	while(c!= '\n' && c != EOF) {
		read_char();
		c = peek_char();
	}

	BEGIN(INITIAL);
}

<undef>. {
	accept();

	string msg;
	msg += "Found unexpected \"";
	msg += yytext;
	msg += "\" in #undef directive.";
	yyerror(msg);

	BEGIN(endif);
}

<endif>"#"[ \t]*"if".* {
	// If we find (if|ifdef|ifndef), increment our depth by 1
	accept();
	is_conditional_source++;
}

<endif>"#"[ \t]*"else"[\ t]+ {
	// If we find #else while looking for #endif, tokenize the else code
	if(is_conditional_source) { BEGIN(INITIAL); }
}

<endif>"#"[ \t]*"endif".* {
	accept();
	if(is_conditional_source == 0) {
		yyerror("Found #endif with no matching #if/#ifdef/#ifndef.");
	} else {
		is_conditional_source--;
	}
	BEGIN(INITIAL);
}

<endif>\n.* {
	accept();
	// Increment the line count
	inputs.front()->current_line = yytext+1;
	inputs.front()->line_number++;
	inputs.front()->col_number = 0;
}

<endif>. {
	accept();
}

<pragma,include,ifndef,ifdef,define,endif>. {
	accept();
	yyerror("Unhandled characters following pre-processor directive.");
	yyterminate();
}

"namespace" {
	accept();
	emit(TOKEN_KW_NAMESPACE);
}

"public" {
	accept();
	emit(TOKEN_KW_PUBLIC);
}

"protected" {
	accept();
	emit(TOKEN_KW_PRIVATE);
}

"private" {
	accept();
	emit(TOKEN_KW_PRIVATE);
}

"enum" {
	accept();
	emit(TOKEN_KW_ENUM);
}

"class" {
	accept();
	emit(TOKEN_KW_CLASS);
}

"struct" {
	accept();
	emit(TOKEN_KW_STRUCT);
}

"typedef" {
	accept();
	emit(TOKEN_KW_TYPEDEF);
}

"int" {
	accept();
	emit(TOKEN_KW_INT);
}

"unsigned" {
	accept();
	emit(TOKEN_KW_UNSIGNED);
}

"::" {
	// Scoping operator
	accept();
	emit(TOKEN_OP_CONS);
}

"&" {
	accept();
	emit(TOKEN_OP_AND);
}

"*" {
	accept();
	emit(TOKEN_OP_STAR);
}

"/*" {
	// Comment block
	accept();
	inputs.front()->comments.back() += scan_block_comment();
}

"//".* {
	// C++-style comment
	accept();
	inputs.front()->comments.back() += (yytext + 2);
}

["] {
	// String literal (")
	accept();
	yylval.string = new string(scan_string_literal());
	emit(TOKEN_STRING);
}

['] {
	// Character literal (')
	accept();
	yylval.character = read_char_const();
	if(peek_char() != '\'') {
		yyerror("Treesap doesn't support multi-character character constants.");
		scan_string_literal('\''); // Consome the rest of the characters
	}
	emit(TOKEN_CHAR);
}

{BOOLEAN_LITERAL} {
	// Boolean literal
	accept();
	if(strcmp(yytext, "true") == 0) {
		yylval.boolean = true;
	} else {
		yylval.boolean = false;
	}
	emit(TOKEN_BOOLEAN);
}

{OCTAL_LITERAL} {
	// Octal literal (currently we just accept 0)
	accept();
	yylval.integer = 0;
	emit(TOKEN_INTEGER);
}

{DECIMAL_LITERAL} {
	// Decimal literal
	accept();
	yylval.integer = atoi(yytext);
	emit(TOKEN_INTEGER);
}

{FLOAT_LITERAL} {
	// Floating-point literals
	accept();
	yylval.floating = atof(yytext);
	emit(TOKEN_FLOAT);
}

{IDENTIFIER} {
	accept();
	yylval.string = new string(yytext);
	emit(TOKEN_IDENTIFIER);
}

. {
	// Send any other printable character as itself.
	accept();
	emit(yytext[0]);
}

<<EOF>> {
	// Stop reading our current file
	yypop_buffer_state();
	inputs.pop_front();

	// Check if we have a file to return to (for example, after an #include)
	if(!YY_CURRENT_BUFFER) {
		// Check if we have inputs left in our queue
		if(inputs.empty()) {
			yyterminate();
		}

		yyin = fopen(inputs.front()->name.c_str(), "r");
		if(!yyin) {
			yyerror("Could not open file \"" + inputs.front()->name + "\" for scanning.");
			yyterminate();
		}

		yypush_buffer_state(yy_new_buffer(yyin, YY_BUF_SIZE));
	}
}

%%

// accept is called above as each piece is pulled off and
// accepted by the lexer; it increments the current column number.
static void accept() {
	yylloc.file = inputs.front();
	yylloc.first_line = inputs.front()->line_number;
	yylloc.first_column = inputs.front()->col_number;
	inputs.front()->col_number += yyleng;
}

// peek_char returns the character that will be returned by read_char next.
inline int peek_char()
{
	int c = yyinput();
	unput(c);
	return c;
}

// read_char reads and returns a single character,
//     incrementing the line and column numbers as appropriate.
inline int read_char() {
	return read_char(inputs.front()->line_number, inputs.front()->col_number);
}
static int read_char(int & line, int & col) {
	int c = yyinput();
	if (c == '\n') {
		line++;
		col = 0;
	} else {
		col++;
	}
	return c;
}

inline char read_char_const(bool auto_escape) {
	return read_char_const(inputs.front()->line_number, inputs.front()->col_number, auto_escape);
}
static char read_char_const(int & line, int & col, bool auto_escape) {
	int c;

	if(!auto_escape) { c = '\\'; }
	else { c = read_char(line, col); }

	if(c != '\\') { return c; }

	// Handle escape sequence
	c = read_char(line, col);
	switch(c) {
		case 'a':
			return '\a';
		case 'b':
			return '\b';
		case 'f':
			return '\f';
		case 'n':
			return '\n';
		case 'r':
			return '\r';
		case 't':
			return '\t';
		case 'v':
			return '\v';
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		{
			int oct = (c - '0'); // integer value

			c = peek_char();
			if(c < '0' || c > '7') { return oct; }
			for(int i = 0; i < 2; ++i) {
				read_char(line, col);
				oct = oct * 8 + (c - '0');

				c = peek_char();
				if(c < '0' || c > '7') { return oct; }
			}
			if(oct > 255) {
				yyerror("Octal escape sequence out of range.");
			}
			return (char)oct;
		}
		case 'x':
		{
			int hex = 0;

			c = peek_char();
			if(!isxdigit(c)) { return hex; }
			for(int i = 0; i < 2; i++) {
				read_char(line, col);
				hex = hex * 16 + (isdigit(c) ? (c - '0') : tolower(c) - 'a' + 10);

				c = peek_char();
				if(!isxdigit(c)) { return hex; }
			}
			return (char)hex;
		}
		case 'u':
			yyerror("Treesap hasn't implement unicode escape sequences yet!");
			return 'u';
		default:
			return c;
	}
}

// for scan_if
static string eat_word() {
	string word;

	int c = peek_char();
	while(isalpha(c) || c == '_') {
		word += read_char();
		c = peek_char();
	}

	return word;
}

// for scan_if
static void eat_space() {
	int c = peek_char();
	while(isblank(c)) {
		read_char();
		c = peek_char();
	}
}

static bool scan_if_condition() {
	eat_space();

	int c = peek_char();
	if(!isalpha(c) && c != '_') {
		if(c != '\n' && c != EOF && c != '\\') {
			read_char(); // Position the cursor better for debug output
		}
		yyerror("Found unexpected character in #if, while expecting a condition.");
		scan_if_end();
		return false;
	}

	string condition = eat_word();
	if(condition == "defined") {
		eat_space();
		string def = eat_word();
		if(def.empty()) {
			yyerror("In #if directive, \"defined\" must be followed by an identifier.");
		}

		if(defines.find(def) == defines.end()) {
			return false;
		} else {
			return true;
		}
	} else {
		yyerror("Treesap hasn't implemented the condition \"" + condition + "\".");
		scan_if_end();
		return false;
	}
}

static bool scan_if_logic(bool current) {
	int c = peek_char();
	switch(c) {
		case '|':
			read_char(); // Eat first '|'
			if(peek_char() != '|') {
				yyerror("Bad logic operator in #if.");
				scan_if_end();
				return false;
			}
			read_char(); // Eat second '|'

			if(current) { return true; }
			else { return scan_if_condition(); }
		case '&':
			read_char(); // Eat first '&'
			if(peek_char() != '&') {
				yyerror("Bad logic operator in #if.");
				scan_if_end();
				return false;
			}
			read_char(); // Eat second '&'

			if(current) { return scan_if_condition(); }
			else { return false; }
		case ' ':
		case '\t':
			eat_space();
			return scan_if_logic(current);
		case '\n':
			return current;
			break;
		case EOF:
			return current;
			break;
		case '\\':
			read_char();
			c = peek_char();
			if(c == '\\') {
				while(c != '\n') {
					read_char();
					c = peek_char();
				}
				return current;
			} else if(c == '\n') {
				read_char();
				return scan_if_logic(current);
			}

			// else fallthrough

		default:
			yyerror("Found unexpected character in #if directive.");
			scan_if_end();
			return false;
			break;
	}	
}

static void scan_if_end() {
	int c = peek_char();
	switch(c) {
		case '\n':
			return;
		case EOF:
			return;
		case '\\':
			read_char();
			c = peek_char();
			if(c == '\\') {
				while(c != '\n') {
					read_char();
					c = peek_char();
				}
				return;
			} else if(c == '\n') {
				read_char();
				scan_if_end();
				return;
			}
		default:
			read_char();
			scan_if_end();
			return;
	}
}

static bool scan_if() {
	bool yes = scan_if_condition();
	return scan_if_logic(yes);
}

static void scan_define(const string& identifier) {
	Define def;
	def.identifier = identifier;
	def.location = Location(inputs.front());

	eat_space();

	string replace;
	int c = read_char();
	while(c != EOF && c != '\n') {
		int p = peek_char();
		if(c == '\\' && p == '\n') {
			read_char();
		} else {
			replace += c;
		}

		c = read_char();
	}
	unput(c);

	def.replace_text = replace;
	defines.emplace(identifier, def);
}

static string scan_block_comment() {
	// We don't touch the current line number and column number during
	// scanning, so that if we detect a warning while scanning the comment
	// (e.g. an unterminated block comment), we'll report the warning as
	// occurring at the start of the comment, not at the end--somewhat
	// more convenient for the user.
	string result;
	int line = inputs.front()->line_number;
	int col = inputs.front()->col_number;

	int c = read_char(line, col);
	while(c != EOF) {
		if(c == '*' && peek_char() == '/') { break; }
		c = read_char(line, col);
	}

	if(c == EOF) {
		yyerror("Block comment is missing a terminating \"*/\"."); 
	} else {
		read_char(line, col); // consume '/' following the '*'
	}

	inputs.front()->line_number = line;
	inputs.front()->col_number = line;

	return result;
}

static string scan_string_literal(char quote_mark) {
	// We don't touch the current line number and column number during
	// scanning, so that if we detect an error while scanning the string
	// (e.g. an unterminated string), we'll report the error as
	// occurring at the start of the string, not at the end--somewhat
	// more convenient for the user.
	string result;
	int line = inputs.front()->line_number;
	int col = inputs.front()->col_number;

	int c = read_char(line, col);
	while(c != quote_mark && c != EOF) {
		// A newline is not allowed within a string unless it is escaped.
		if(c == '\n') {
			c = EOF;
			break;
		}

		if(c == '\\') {
			result += read_char_const(line, col, true);
		} else {
			result += c;
		}

		c = read_char(line, col);
	}

	if(c == EOF)
	{
		yyerror("String const is missing a terminating (\") character."); 
	}

	inputs.front()->line_number = line;
	inputs.front()->col_number = line;

	return result;
}

static bool accept_include(char end_mark) {
	// Get the string between the quotes
	string filename;
	int line = inputs.front()->line_number;
	int col = inputs.front()->col_number;

	int c = read_char(line, col);
	while(c != end_mark && c != EOF) {
		filename += c;
		c = read_char(line, col);
	}

	if(c == EOF) {
		string msg = "#include filename missing a terminating (";
		yyerror(msg + "\" character.");
		return false;
	}

	if(filename.empty()) {
		yyerror("#include must be given a filename.");
		return false;
	}

	string fileref;
	vector<string> dirs;

	if(end_mark == '\"') {
		yyin = fopen(filename.c_str(), "r");
		if(yyin) {
			fileref = filename;
			goto eatline;
		}
	}

	dirs = get_compiler_includes();
	for(auto it = dirs.begin(); it != dirs.end(); ++it) {
		string filepath = (*it) + filename;
		yyin = fopen(filepath.c_str(), "r");
		if(yyin) {
			fileref = filepath;
			goto eatline;
		}
	}

	if(!yyin) {
		yyerror("Could not open file " + filename + " for scanning.");
		return false;
	}

  eatline:
	inputs.front()->line_number = line;
	inputs.front()->col_number = col;

	c = peek_char();
	while(c != EOF && c != '\n') {
		read_char();
		switch(c) {
			case ' ':
			case '\t':
				// Eat any whitespace
				break;
			case '/':
				// Ignore comments
				goto stop;
			default:
				yywarning("Junk characters after #include.");
				goto stop;
		}
		c = peek_char();
	}

  stop:
  	auto prev_include = files.find(fileref);
  	if(prev_include != files.end()) {
  		if(prev_include->second->type != FTInput) {
  			yyerror("Name conflict with included file.");
  			return false;
  		}

  		Input* input = (Input*)(prev_include->second);
  		inputs.push_front(input);
  		input->times_included++;
  	} else {
  		Input* input = new Input(fileref);
		inputs.push_front(input);
		files.emplace(input->name, input);  		
  	}

	// Switch to the new buffer
	yypush_buffer_state(yy_new_buffer(yyin, YY_BUF_SIZE));
	return true;
}

static ostream& indent(ostream& out, unsigned int indent_level) {
	for(unsigned int i = 0; i < indent_level; i++) {
		out << ' ';
	}
	return out;
}

Module* init_lexer(const string & filename) {
	error_count = 0;
	warning_count = 0;

	current_module = new Module();

	defines.clear();
	vector<Define> predefines = get_compiler_defines();
	for(auto it = predefines.begin(); it != predefines.end(); ++it) {
		defines.emplace(it->identifier, (*it));
	}

	inputs.clear();
	Input* input = new Input(filename);
	inputs.push_front(input);
	files.emplace(filename, input);

	//yyout = fopen("/dev/null", "w");
	yyin = fopen(filename.c_str(), "r");
	if(!yyin) { return NULL; }
	return current_module;
}

int lexer_error_count() { return error_count; }
int lexer_warning_count() { return warning_count; }
void lexer_error(const string & msg)
{
	Input* info = inputs.front();

	cerr << "Error";
	if(!info->name.empty()) {
		cerr << " in " << info->name;
	}
	cerr << " at line " << info->line_number << ", column " << info->col_number
	     << ":\n" << info->current_line << "\n";

	int ident = info->col_number - 1 < 0 ? 0 : info->col_number - 1;
	indent(cerr, info->col_number - 1) << "^\n";
	cerr << msg << "\n\n";

	error_count++;
}
void lexer_warning(const string & msg)
{
	Input* info = inputs.front();

	cerr << "\nWarning";
	if(!info->name.empty()) {
		cerr << " in " << info->name;
	}
	cerr << " at line " << info->line_number << ", column " << info->col_number
	     << ":\n" << info->current_line << "\n";
	indent(cerr, info->col_number - 1) << "^\n" << msg << "\n\n";

	warning_count++;
}

Input::Input(const string& name) : File(name, FTInput), line_number(0), col_number(0), times_included(1) {
	comments.push_back(string());
}
