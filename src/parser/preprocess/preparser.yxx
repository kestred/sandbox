/* Filename: parser.yxx */

%{
	#include "prelexer.h"
	#include "preparser.h"

	#include "parser/cpp.h"
	using namespace std;

	#define yylex ppr_yylex
	#define yylval ppr_yylval

	static bool result;
	static Module* current_module;
	#define macros (current_module->macros)
%}

/* Set Parser Options */
%error-verbose // has bison output verbose errors

//%define api.namespace {treesap}
%define api.prefix {ppr_yy}
%define api.token.prefix {PRETOKEN_} // prefix tokens with PRETOKEN_ to avoid name conflicts

/* Define our YYSTYPE */
%union {
	int integer;
	bool boolean;
	char character;
	double floating;
	std::string* string;
}

/* Lexing Symbols */
%token END 0 "end of file" // error messages refer to "end of file" intead of $end

/* Literal Tokens */
%token <integer>   INTEGER
%token <floating>  FLOAT
%token <character> CHAR
%token <boolean>   BOOLEAN

/* Semantic Tokens */
%token <string> IDENTIFIER

/* Keyword Tokens */
%token KW_DEFINED "defined"

/* Operator Tokens */
%token OP_AND "&&"
%token OP_OR  "||"
%token OP_EQ  "=="
%token OP_NEQ "!="
%token OP_GRE ">="
%token OP_LTE "<="
%token OP_LT  "<"
%token OP_GR  ">"
%token OP_NOT "!"
%token OP_SUB "-"
%token OP_ADD "+"
%token OP_BITLEFT  "<<"
%token OP_BITRIGHT ">>"

/* Operator Precedence and Associativity */
%left "||"
%left "&&"
%left "==" "!="
%left "<" "<=" ">" ">="
%left "<<" ">>"
%right "+" "-"
%right "!"

/* Non-terminals */
%type <boolean> expr_condition
%type <boolean> condition
%type <boolean> cond_defined
%type <boolean> cond_compare

%type <floating> expr_equation
%type <floating> number


%%


grammar
	: if_directive
	;

if_directive
	: expr_condition { result = $1; }
	| number { result = (bool)$1; }
	;

expr_condition
	: condition
	| expr_condition "&&" condition
	{
		if($1) { $$ = $3; }
		else { $$ = false; }
	}
	| expr_condition "||" condition
	{
		if($1) { $$ = true; }
		else { $$ = $3; }
	}
	;

condition
	: cond_defined
	| cond_compare
	| "!" condition { $$ = !$2; }
	| '(' expr_condition ')' { $$ = $2; }
	;

cond_compare
	: expr_equation "==" expr_equation
	{
		$$ = ($1 == $3);
	}
	| expr_equation "!=" expr_equation
	{
		$$ = ($1 != $3);
	}
	| expr_equation "<=" expr_equation
	{
		$$ = ($1 <= $3);
	}
	| expr_equation ">=" expr_equation
	{
		$$ = ($1 >= $3);
	}
	| expr_equation "<" expr_equation
	{
		$$ = ($1 < $3);
	}
	| expr_equation ">" expr_equation
	{
		$$ = ($1 > $3);
	}
	| undefined "==" expr_equation { $$ = false; }
	| undefined "!=" expr_equation { $$ = false; }
	| undefined "<=" expr_equation { $$ = false; }
	| undefined ">=" expr_equation { $$ = false; }
	| undefined "<" expr_equation { $$ = false; }
	| undefined ">" expr_equation { $$ = false; }
	| expr_equation "==" undefined { $$ = false; }
	| expr_equation "!=" undefined { $$ = false; }
	| expr_equation "<=" undefined { $$ = false; }
	| expr_equation ">=" undefined { $$ = false; }
	| expr_equation "<" undefined { $$ = false; }
	| expr_equation ">" undefined { $$ = false; }
	;

cond_defined
	: "defined" IDENTIFIER
	{
		if(macros.find(*$2) == macros.end()) {
			$$ = false;
		} else {
			$$ = true;
		}
		delete $2;
	}
	| "defined" '(' IDENTIFIER ')'
	{
		if(macros.find(*$3) == macros.end()) {
			$$ = false;
		} else {
			$$ = true;
		}
		delete $3;
	}
	;

expr_equation
	: number
	| expr_equation ">>" expr_equation { $$ = (int)($1 + 0.5) >> (int)($3 + 0.5); }
	| expr_equation "<<" expr_equation { $$ = (int)($1 + 0.5) << (int)($3 + 0.5); }
	| expr_equation "+" expr_equation { $$ = $1 + $3; }
	| expr_equation "-" expr_equation { $$ = $1 - $3; }
	| '(' expr_equation ')' { $$ = $2; }
	;

number
	: INTEGER { $$ = $1; }
	| FLOAT
	| CHAR { $$ = $1; }
	| BOOLEAN { $$ = $1; }
	;

undefined
	: IDENTIFIER
	{
		delete $1;
	}
	;

%%

/* ---- User Subroutines ---- */
bool parse_if_directive(Module * module, const std::string & input) {
	init_prelexer(module, input);

	result = false;
	current_module = module;
	if(yyparse() != 0) { return false; }
	return result;
}
