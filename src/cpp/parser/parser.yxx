/* Filename: parser.yxx */

%{
	#include "lexer.h"
	#include "parser.h"
	#include "tokens.h"

	#include "cpp/cpp.h"

	#define yyerror cpperror
	#define yywarning cppwarning

	using namespace std;

	static string current_error;

	static Module* module = NULL;
	static File* current_file = NULL;

	// outer_scope is the appropriate scope for declarations and
	//     definitions that have external linkage.
	static Scope* outer_scope = NULL;

	// inner_scope is the appropriate scope for declarations and
	//     definitions that have internal linkage.
	static Scope* inner_scope = NULL;

	// is_varname_free returns true if a provided identifier is not used as a
	//     symbol or can be masked as a varname in a provided scope.
	static bool is_varname_free(const string& name);
	static bool is_varname_free(const string& name, const Scope* scope);

	// is_typename_free returns true if a provided identifier is not used as a
	//     symbol or can be masked as a typename in a provided scope.
	static bool is_typename_free(const string& name);
	static bool is_typename_free(const string& name, const Scope* scope);

	// is_declared_typename returns true if a type with a provided name is
	//     visible from the provided scope. It may be declared in another scope.
	static bool is_declared_typename(const string& name);
	static bool is_declared_typename(const string& name, const Scope* scope);

	// is_defined_typename returns true if a type with a provided name is
	//     visible from the provided scope and it has a complete definition.
	static inline bool is_defined_typename(const string& name);
	static inline bool is_defined_typename(const string& name, const Scope* scope);

	// get_type returns a pointer to the type visible in a provided scope
	//     with a provided name. Returns NULL if no such type exists.
	static Type* get_type(const string& name);
	static Type* get_type(const string& name, Scope* scope);
	static const Type* get_type(const string& name, const Scope* scope);

	// print_type_difference returns a human readable debugging string describing the
	//     differences between a previously defined type and a newly defined type.
	static string print_type_difference(const Type* defined, const set<Attribute>& defining);

	// print_location returns a human readable string representing the given location.
	static string print_location(const Location& loc);
%}

/* Set Parser Options */
%glr-parser    // using glr so we can allow some conflicts in ambiguous C++ grammar
%error-verbose // has bison output verbose errors
%locations     // enable location tracking; we use this to pair comments with tokens

//%define api.namespace {treesap}
%define api.prefix {cpp}
%define api.token.prefix {TOKEN_} // prefix tokens with TOKEN_ to avoid name conflicts

/* Define our YYSTYPE */
%union {
	int integer;
	bool boolean;
	char character;
	double floating;
	std::string* string;
	File* file;
}

/* Lexing Symbols */
%token END 0 "end of file" // error messages refer to "end of file" intead of $end
%token <file> FILE_SCOPE "change in file scope"

/* Literal Tokens */
%token <integer>   INTEGER
%token <floating>  FLOAT
%token <string>    STRING
%token <character> CHAR
%token <boolean>   BOOLEAN

/* Semantic Tokens */
%token <string> IDENTIFIER

/* Keyword Tokens */
%token KW_NAMESPACE "namespace"
%token KW_CONST     "const"

// Access specifiers
%token KW_PUBLIC    "public"
%token KW_PROTECTED "protected"
%token KW_PRIVATE   "private"

// Type-definitions
%token KW_ENUM     "enum"
%token KW_STRUCT   "struct"
%token KW_CLASS    "class"
%token KW_TYPEDEF  "typedef"
%token KW_TYPENAME "typename"
%token KW_TEMPLATE "template"

// Fundamental-type keywords
%token KW_INT      "int"
%token KW_CHAR     "char"
%token KW_DOUBLE   "double"
%token KW_UNSIGNED "unsigned"
%token KW_SIGNED   "signed"
%token KW_LONG     "long"
%token KW_SHORT    "short"
%token KW_BOOL     "bool"

// Compiler directives
%token KW_ATTRIBUTE "__attribute__"
%token ATTR_VISIBILITY "__visibility__"
%token ATTR_NORETURN "__noreturn__"

// Keyword-operators
%token KW_SIZEOF   "sizeof"
%token KW_DECLTYPE "decltype"

/* Operator Tokens */
%token OP_ASSIGN  "="
%token OP_EQUALS  "=="

// We're naming most ops by their symbol, because they're overload
%token OP_CONS    "::"
%token OP_ANDAND  "&&"
%token OP_AND     "&"
%token OP_BARBAR  "||"
%token OP_BAR     "|"
%token OP_STAR    "*"
%token OP_ANGLE_L "<"
%token OP_ANGLE_R ">"

/* Precedence */
%left ','
%right "throw"
%right "?:" "=" "+=" "-=" "*=" "/=" "%=" "<<=" ">>=" "&=" "^=" "|="
%left "||"
%left "&&"
%left "|"
%left "^"
%left "&"
%left "==" "!="
%left "<" "<=" ">" ">="
%left "<<" ">>"
%right "+" "-"
%right "*" "/" "%"
%right "!" "~"  '(' ')' "new" "new[]" "delete" "delete[]" "sizeof"
%left "()" '[' ']' '.' "->"
%left "::"

/* Non-terminals */
%type <string> struct_identifier


%%

cxx : empty
	| FILE_SCOPE
	{
		current_file = $1;
		inner_scope = &current_file->scope;
	}
	| declarations
	| error ';'
	{
		yyerror(current_error);
		current_error.clear();
	}
	;

declarations
	: declaration
	| declarations declaration
	;

declaration
	: namespace_decl
	| method_decl ';'
	| class_decl ';'
	| struct_decl ';'
	| enum_decl ';'
	| typedef_decl ';'
	| variable_decl ';'
	;

statements
	: statement
	| statements statement
	;

statement
	: expression ';'
	;

expression
	: qualified_name
	| raw_value
	| boolean_value
	| cast_value
	| type_initializer
	| '(' expression ')'
	;

boolean_value
	: expression "==" expression
	| expression "!=" expression
	| expression "<=" expression
	| expression ">=" expression
	| expression "<" expression
	| expression ">" expression
	| expression "||" expression
	| expression "&&" expression
	| "!" expression
	;

type_initializer
	: type_name '(' argument_list ')'
	| "new" type_name '(' argument_list ')'
	;

cast_value
	: '(' type_name variable_prefix ')' expression
	;

argument_list
	: expression
	| argument_list ',' expression
	;

class_body
	: class_part
	| class_body class_part
	;

class_part
	: declaration
	| access_specifier
	;

access_specifier
	: "public" ':'
	| "protected" ':'
	| "private" ':'
	;

enumeration
	: enum_element
	| enumeration ',' enum_element
	;

enum_element
	: IDENTIFIER
	| IDENTIFIER "=" expression
	;

variable_decl
	: type_name variable_init
	| variable_decl ',' variable_init
	;

variable_init
	: variable_spec
	| variable_spec '=' statement
	;

enum_decl
	: "enum" IDENTIFIER '{' '}'
	| "enum" IDENTIFIER '{' enumeration '}'
	| "enum" '{' enumeration '}'
	;

template_decl
	: "template" "<" template_type_list ">" 
	;

template_type_list
	: template_type
	| template_type_list ',' template_type
	;

template_type
	: template_type_identifier
	| template_type_identifier "=" template_instance_type
	;

template_type_identifier
	: "class"
	| "typename"
	| "class" IDENTIFIER
	| "typename" IDENTIFIER
	;

template_instance_type
	: type_qualified_name "<" type_list ">"
	| type_qualified_name "<" raw_value_list ">"
	;

template_spec
	: "template" "<" ">"
	;

template_spec_with_instance_type
	: "template" "<" type_list ">"
	;

class_decl
	: class_identifier         // declaration
	| class_identifier '{' '}' // definition
	| class_identifier '{' class_body '}'
	;

class_identifier
	: "class" IDENTIFIER
	| template_decl "class" IDENTIFIER
	| template_spec "class" template_instance_type
	| template_spec_with_instance_type "class" IDENTIFIER
	;

struct_decl
	: struct_identifier         // declaration
	| struct_identifier '{' '}' // definition
	{
		string name = *$1;
		bool defined = is_defined_typename(name);
		if(defined) {
			current_error = "Redefinition of 'struct " + name + "'.\n"
				+ "\n\tPreviously defined: " + print_location(get_type(name)->definition) + "\n";
		}
	}
	| struct_identifier '{' class_body '}'
	;

struct_identifier
	: "struct" IDENTIFIER
	{
		string name = *$2;
		set<Attribute> attribs({Attribute("subtype", "class")});
		bool declared = is_declared_typename(name);
		if(declared) {
			Type* t = get_type(name);
			if(t->attributes != attribs) {
				current_error = "'struct " + name + '\'' + print_type_difference(t, attribs)
					+ "\n\tFirst declared: " + print_location(t->declarations.front()) + "\n";
				YYERROR;
			}
			t->declarations.push_back(yylloc);
		} else if(is_typename_free(name)) {
			outer_scope->types.emplace(name, Type(attribs, yylloc));
			outer_scope->symbols.emplace(name, Symbol(name, TYPENAME_SYMBOL, outer_scope));
			printf("Foo: %s", $2->c_str());
		} else {
			current_error = "TODO: name for struct has conflict";
			YYERROR;
		}

		$$ = $2;
	}
	| template_decl "struct" IDENTIFIER
	{
		// TODO
	}
	| template_spec "struct" template_instance_type
	{
		// TODO
	}
	| template_spec_with_instance_type "struct" IDENTIFIER
	{
		// TODO
	}
	;

typedef_decl
	: "typedef" type_name variable_spec
	;

namespace_decl
	: "namespace" attribute_directive '{' '}'
	| "namespace" attribute_directive '{' declarations '}'
	| "namespace" IDENTIFIER attribute_directive '{' '}'
	| "namespace" IDENTIFIER attribute_directive '{' declarations '}'
	;

method_decl
	: type_name variable_spec '(' ')' method_body attribute_directive
	| type_name variable_spec '(' method_params ')' method_body attribute_directive
	;

method_params
	: method_param
	| method_params ',' method_param
	;

method_param
	: type_name variable_with_optional_name
	;

variable_with_optional_name
	: variable_prefix
	| variable_spec
	;

attribute_directive
	: empty
	| "__attribute__" '(' '(' attribute_list ')' ')'
	;

attribute_list
	: compiler_attribute 
	| attribute_list ',' compiler_attribute
	;

compiler_attribute
	: "__visibility__" '(' STRING ')'
	| "__noreturn__"
	;

method_body
	: empty
	| '{' statements '}'
	;

variable_spec
	: variable_prefix IDENTIFIER
	;

variable_prefix
	: empty
	| "&"
	| "*" variable_prefix
	;

type_name
	: integer_type
	| "bool"
	| type_qualified_name
	| template_instance_type
	| "decltype" '(' IDENTIFIER ')'
	| type_const_name
	;

type_qualified_name
	: qualified_name
	| "typename" qualified_name
	;

type_const_name
	: "const" integer_type
	| "const" type_qualified_name
	| "const" template_instance_type
	;

type_list
	: type_name
	| type_list ',' type_name
	;

raw_value_list
	: raw_value
	| raw_value ',' raw_value_list
	;

raw_value
	: BOOLEAN
	| INTEGER
	| FLOAT
	| CHAR
	| STRING
	;

// For this rule, we'll allow almost everything in the grammar, but manually
//     check to make sure the user isn't insane.
integer_type
	: "short"
	| "char"
	| "long"
	| "int"
	| "unsigned"
	| "signed"
	| integer_type "char"
	| integer_type "short"
	| integer_type "long"
	| integer_type "int"
	| integer_type "unsigned"
	| integer_type "signed"
	;

qualified_name
	: IDENTIFIER
	| qualified_name "::" IDENTIFIER
	;

/*
string_literal
	: STRING
	| string_literal STRING
	;
*/

empty
	:
	;

%%

/* ---- API Subroutines ---- */
Module* run_parser(const std::string & filename) {
	module = init_lexer(filename);
	if(!module) { return NULL; }
	current_file = module->files[filename];
	inner_scope = &current_file->scope;
	outer_scope = &module->global;
	if(yyparse() != 0 || cpp_errors() > 0) { return NULL; }
	return module;
}


/* --- Helper Subroutines --- */
bool is_varname_free(const string& name, const Scope* scope) {
	// Check if a similar variable exists in the same scope, we can mask parents
	auto found = scope->symbols.find(name);
	if(found == scope->symbols.end())
	{
		return true;
	}

	// If the scope of found isn't the current scope, we can mask the value
	if(found->second.scope != scope)
	{
		return true;
	}

	// Type names don't conflict with variable names.
	if(found->second.type == TYPENAME_SYMBOL)
	{
		return true;
	}

	return false;
}
bool is_varname_free(const string& name) {
	return is_varname_free(name, inner_scope) && is_varname_free(name, outer_scope);
}

bool is_typename_free(const string& name, const Scope* scope) {
	auto found = scope->symbols.find(name);
	if(found == scope->symbols.end())
	{
		return true;
	}

	// If the scope of found isn't the current scope, we can mask the value
	if(found->second.scope != scope)
	{
		return true;
	}

	// Variable names don't conflict with type names.
	if(found->second.type == VARIABLE_SYMBOL)
	{
		return true;
	}

	return false;
}
bool is_typename_free(const string& name) {
	return is_typename_free(name, inner_scope) && is_varname_free(name, outer_scope);
}

bool is_declared_typename(const string& name, const Scope* scope) {
	while(scope != NULL) {
		if(scope->types.find(name) != scope->types.end())
		{
			return true;
		}
		scope = scope->parent;
	}

	return false;
}
bool is_declared_typename(const string& name) {
	if(inner_scope->types.find(name) != inner_scope->types.end()) {
		return true;
	}

	return is_declared_typename(name, outer_scope);
}

bool is_defined_typename(const string& name, const Scope* scope) {
	const Type* t = get_type(name, scope);
	return (t != NULL) && (t->definition.file != NULL);
}
bool is_defined_typename(const string& name) {
	Type* t = get_type(name);
	return (t != NULL) && (t->definition.file != NULL);
}


Type* get_type(const string& name, Scope* scope) {
	while(scope != NULL) {
		auto found = scope->types.find(name);
		if(found != scope->types.end())
		{
			return &found->second;
		}

		scope = scope->parent;
	}

	return NULL;
}
const Type* get_type(const string& name, const Scope* scope) {
	while(scope != NULL) {
		auto found = scope->types.find(name);
		if(found != scope->types.end())
		{
			return &found->second;
		}

		scope = scope->parent;
	}

	return NULL;
}
Type* get_type(const string& name) {
	auto found = inner_scope->types.find(name);
	if(found != inner_scope->types.end())
	{
		return &found->second;
	}

	return get_type(name, outer_scope);
}

string print_type_difference(const Type* defined, const set<Attribute>& defining)
{
	return "TODO: Bad type";
}

string print_location(const Location& loc)
{
	return "TODO: Location";
}
